# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
load(here("data", "culvert_lines_sf.rda"))
library(here)
load(here("data", "culvert_lines_sf.rda"))
View(culvert_lines_sf)
View(culvert_lines_sf)
attachment::att_amend_desc()
??attachment::att_amend_desc()
?att_amend_desc()
?att_from_rscripts()
usethis::use_package('leafgl')
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
library(here)
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
library(here)
setwd("/Users/sunnyjardine/Library/CloudStorage/Dropbox/upstream/upstream")
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
setwd("/Users/sunnyjardine/Dropbox/upstream/upstream")
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
library(here)
library(tidyverse)
load("upstream_inputs.Rdata")
load(here("data-raw", "upstream_inputs.Rdata"))
load(here("data-raw", "upstream_inputs_gm.Rdata"))
leaflet_proxy <- m %>%
leaflet::addPolygons(
popup =  ~ paste0(
"<b>WRIA Name:</b> ",
WRIA_NM,
"<br>",
"<b>WRIA Number:</b> ",
WRIA_NR
),
weight = 1.5,
opacity = 1,
color = "#1c1cff",
fillColor = "transparent"
)
leaflet_proxy <-  wrias %>%
leaflet::leaflet() %>%
leaflet::addProviderTiles("CartoDB.Positron", group = "Grayscale", options = leaflet::providerTileOptions(minZoom = 6.5))  %>%
leaflet::addScaleBar("bottomleft")
leaflet_proxy <- leaflet_proxy %>% %>%
leaflet_proxy <- leaflet_proxy  %>%
leaflet::addPolygons(
popup =  ~ paste0(
"<b>WRIA Name:</b> ",
WRIA_NM,
"<br>",
"<b>WRIA Number:</b> ",
WRIA_NR
),
weight = 1.5,
opacity = 1,
color = "#1c1cff",
fillColor = "transparent"
)
leaflet_proxy <- leaflet_proxy %>% leaflet::addCircleMarkers(
data = culverts_cmb,
group = "culverts",
radius = 5,
weight = 1.5,
color = ~ifelse(bad_match, "black", "darkgrey"), # marks bad matches
opacity = 1,
fillColor = 'grey',
fillOpacity = 1,
clusterOptions = leaflet::markerClusterOptions(
iconCreateFunction = htmlwidgets::JS("function (cluster) {
var childCount = cluster.getChildCount();
if (childCount < 500) {
c = 'rgba(241, 226, 185, 255);'
} else if (childCount < 1000) {
c = 'rgba(197, 247, 244, 255);'
} else {
c = 'rgba(232, 169, 157, 255);'
}
return new L.DivIcon({ html: '<div style=\"background-color:'+c+'\"><span>' + childCount + '</span></div>',
className: 'marker-cluster', iconSize: new L.Point(40, 40) });}"),
spiderfyOnMaxZoom = FALSE,
disableClusteringAtZoom = 10
),
popup = ~popup
)
leaflet_proxy
wrias %>% dplyr::arrange(WRIA_NM) %>% dplyr::pull(WRIA_NM)
wrias %>% dplyr::arrange(WRIA_NM) %>% dplyr::pull(WRIA_NR)
wrias %>% filter(WRIA_NR = 14)
wrias %>% filter(WRIA_NR == 14)
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
map_leaflet_custom(
leaf_proxy = leaf_proxy,
points = culverts_cmb_gm, #culverts
lines = lines_simp_gm, #lines with linestring geometries
dslines = lines_ds_gm, #downstream lines with linestring geometries
prtf_cust = "115 MC040", #inputs from mod_Custom
E = E_gm, #full connectivity matrix
marginal_line_ids = marginal_line_ids_gm, #comids for all lines marginally upstream of each point
downstream_line_ids = downstream_line_ids_gm #comids for all lines downstream of each point on main stem
)
map_leaflet_custom(
leaf_proxy = leaflet_proxy,
points = culverts_cmb_gm, #culverts
lines = lines_simp_gm, #lines with linestring geometries
dslines = lines_ds_gm, #downstream lines with linestring geometries
prtf_cust = "115 MC040", #inputs from mod_Custom
E = E_gm, #full connectivity matrix
marginal_line_ids = marginal_line_ids_gm, #comids for all lines marginally upstream of each point
downstream_line_ids = downstream_line_ids_gm #comids for all lines downstream of each point on main stem
)
leaf_proxy = leaflet_proxy
points = culverts_cmb_gm
lines = lines_simp_gm
dslines = lines_ds_gm
prtf_cust = "115 MC040"
E = E_gm
marginal_line_ids = marginal_line_ids_gm
downstream_line_ids = downstream_line_ids_gm
#Convert custom portfolio to TRUE/FALSE vector
cust <- points$site_id %in% prtf_cust
#Identify points in custom plan that unlock habitat
h_inc <- lapply(1 : length(prtf_cust),
FUN = function(x) ifelse(sum(E[, prtf_cust[x]]) == 0, TRUE,
ifelse(sum(which(E[, prtf_cust[x]] == 1) %in% prtf_cust) ==
length(which(E[, prtf_cust[x]] == 1)), TRUE, FALSE))) %>%
do.call("rbind", .) %>%
as.logical()
#Crop lines to wrias in plan regardless of whether they unlock habitat
cust_wrias <- unique(points[points$site_id %in% prtf_cust, ]$wria_number)
in_cust_wrias <- points$wria_number %in% cust_wrias
#First get blocked/unblocked lines
blocked_lines <- marginal_line_ids[in_cust_wrias] %>% base::unlist()
ds_blocked_lines <- downstream_line_ids[in_cust_wrias] %>% base::unlist()
leaflet_lines <- lines %>% dplyr::filter(COMID %in% blocked_lines)
ds_leaflet_lines <- dslines %>% dplyr::filter(COMID %in% ds_blocked_lines)
#Defined blocked/unblocked
names(marginal_line_ids) <- points$site_id
milp_stream_ids <- marginal_line_ids[prtf_cust[h_inc]] %>% base::unlist()
ds_stream_ids <- downstream_line_ids[prtf_cust[h_inc]] %>% base::unlist()
prtf_cust[h_inc]
names(downstream_line_ids) <- points$site_id
milp_stream_ids <- marginal_line_ids[prtf_cust[h_inc]] %>% base::unlist()
ds_stream_ids <- downstream_line_ids[prtf_cust[h_inc]] %>% base::unlist()
#Add lines
leaf_proxy <- leaf_proxy %>%
leafgl::addGlPolylines(data = leaflet_lines %>%
dplyr::filter(!COMID %in% milp_stream_ids),
color = "#cf6e7d",
opacity = 0.5,
group = "blocked_lines"
)  %>%
leafgl::addGlPolylines(
data = leaflet_lines %>%
dplyr::filter(COMID %in% milp_stream_ids),
color = "#2739c7",
opacity = 0.5,
group = "unblocked_lines"
)
#test for null sets in ds lines. If FALSE draw lines
testfilter <- ds_leaflet_lines %>% dplyr::filter(COMID %in% ds_stream_ids & !COMID %in% milp_stream_ids)
if (inherits(sf::st_geometry(testfilter), c("sfc_LINESTRING", "sfc_MULTILINESTRING")) == TRUE){
leaf_proxy <- leaf_proxy %>%
leafgl::addGlPolylines(
data = ds_leaflet_lines %>%
dplyr::filter(COMID %in% ds_stream_ids & !COMID %in% milp_stream_ids),
color = "#b0b0b0",
opacity = 0.25,
group = "unblocked_lines"
) } else {
NULL
}
leaf_proxy
# define project color pallet
pal <- leaflet::colorNumeric(c("#d9a1a0", "#91afeb"), 0 : 1)
# define match border pallet
match_pal <- leaflet::colorFactor(palette = c("black", "transparent"), domain = c(TRUE, FALSE), ordered = TRUE)
#Add culverts
leaf_proxy <- leaf_proxy %>%
leaflet::addCircleMarkers(
data = points,
lng = ~ site_longitude,
lat = ~ site_latitude,
group = "selected_culverts",
radius = 5,
weight = 1.5,
color = ~match_pal(bad_match),
fillColor = ~pal(cust),
fillOpacity = 1,
opacity = 1,
clusterOptions = leaflet::markerClusterOptions(
iconCreateFunction = htmlwidgets::JS("function (cluster) {
var childCount = cluster.getChildCount();
if (childCount < 100) {
c = 'rgba(204, 252, 255, 1.0);'
} else if (childCount < 1000) {
c = 'rgba(237, 192, 181, 1);'
} else {
c = 'rgba(164, 164, 243, 1);'
}
return new L.DivIcon({ html: '<div style=\"background-color:'+c+'\"><span>' + childCount + '</span></div>',
className: 'marker-cluster', iconSize: new L.Point(40, 40) });}"),
spiderfyOnMaxZoom = FALSE,
disableClusteringAtZoom = 10
),
popup = ~popup
)
leaf_proxy
